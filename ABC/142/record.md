# [AtCoder Beginner Contest 142](https://atcoder.jp/contests/abc142)
2019.09.28 21:00~22:40 (100分)

| 問題記号 | 問題名 | 配点 | 実行時間制限/sec | メモリ制限/MB |
----|----|----|----|----
| A | Odds of Oddness | 100 | 2 | 1024 |
| B | Roller Coaster | 200 | 2 | 1024 |
| C | Go to School | 300 | 2 | 1024 |
| D | Disjoint Set of Common Divisor | 400 | 2 | 1024 |
| E | Get Everything | 500 | 2 | 1024 |
| F | Pure | 600 | 2 | 1024 |

## 結果
| 順位 | パフォーマンス | レーティング | 差分 |
----|----|----|----
| 1708/5235 | 1014 | 625 | +67 |

### A - [Odds of Oddness](https://atcoder.jp/contests/abc142/tasks/abc142_a)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 08:47 | 0 | 0 | 0 | 0 |

**[Q] N以下の正整数の中から1つ選んでそれが奇数である確率を求めよ.**

Nが最大で100なので最悪数えていけばよい. ただし型には気をつける必要アリ. Nが偶数の場合は必ず0.5になるので, 計算せずそのまま出力している.

### B - [Roller Coaster](https://atcoder.jp/contests/abc142/tasks/abc142_b)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 11:18 | 0 | 0 | 0 | 0 |

**[Q] 身長値hが与えられたN人の中でKcm以上の人数を求めよ.**

配列にデータを入れて各要素がK以上ならカウントしていって出力するのみ.

### C - [Go to School](https://atcoder.jp/contests/abc142/tasks/abc142_c)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 15:19 | 0 | 0 | 0 | 0 |

**[Q] 出席番号iの生徒が来たときに教室にA[i]人いた, という情報がN人分与えられたとき, 生徒の登校順を復元せよ.**

復元配列をBとするとき, Aを読み込んだ後, B.at(A.at(i)-1) = i+1と入れていく. すでに教室にi人いるならば, 自分はi+1番目に登校したとわかるためである. C問題にしては難易度低めに感じた.

### D - [Disjoint Set of Common Divisor](https://atcoder.jp/contests/abc142/tasks/abc142_d)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 01:04:21 | 0 | 0 | 0 | 0 |

**[Q] 正整数A,Bが与えられたとき, その公約数の中で選んだ整数の中で任意の2つが互いに素になるとき, 最大でいくつ選べるか.**

証明は省略するが, AとBの最大公約数gcd(A,B)を素因数分解して, 素因数を数えていくことで答えが求まる. 素因数を数える関数pfはO(√n*log(N))程度の計算量のため, 今回のNの制約(<=10^12)でも間に合う. またpfで求めた素因数に1は含まれないが, 1と任意の数は必ず互いに素になるので, 素因数の数に+1して出力するようにしておく.  
ひらめくまで40分ほどかかってしまったが, 過去に似たような問題で素因数分解を使ったことを思い出し, それを当てはめていくことで今回解くことができた.

### E - [Get Everything](https://atcoder.jp/contests/abc142/tasks/abc142_e)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| (1) | 0 | 0 | (1) | 0 |

**[Q] 宝箱がN個に対し鍵がM個あり, それぞれ限られた種類の宝箱のみ開けることができる. 鍵は価格が設定されて販売されている. すべての宝箱を開ける為に必要な最小費用を求めよ.**

ビット演算技法の応用である「bitDP」を使うことで解ける. 問題文を見てなんとなくDPを使うことは頭に浮かんでいたが, 時間内に実装に至れなかった. bitDPについては競プロ学習でいつもお世話になっている[けんちょん氏の記事](https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361#bit-dp)を参照.  
順列から最適なものを求めるときに使われ, コストを計算する際に部分集合Sの順序の最後の要素が何かで判断して場合分けを行っている. これにより最終的にdp[S]の値が部分集合Sにおける最適な値(今回でいえば鍵の最小コスト)が入っている. 計算量はO((2^N)\*M). Nはmax12なので普通に間に合う.  
非常に便利で面白い解法と感じたので, 今後似たような問題が出たときに使いこなせるようにしていきたい.

### F - Pure
タイムオーバー

## 実績
| 順位 | Rating | Rating最高値 | コンテスト参加回数 |
----|----|----|----
| 11073 | 625(暫定14) | 625-7級 | 12 |

## 感想
今回は無事4完. なんとか60分ほどでD問題まで解くことができた. D問題は過去の問題を思い出してACに至れたので, やはり経験を積んでいくことが大事だと感じた. 今後はこの経験を素早く引き出せるように訓練して, もう少し早くD問題を解けるようになりたい.  
また4完は最近のABCコンテストにおいては安定してきたが, まだまだE問を解くには遠い実力であり, レートをもっとスピードよく上げていくためにも, そろそろ5完を目標に取り組んでいきたい(せめてパフォ1000は超えるようにしていきたい).
