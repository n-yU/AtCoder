# [AtCoder Beginner Contest 139](https://atcoder.jp/contests/abc139)
2019.09.01 21:00~22:40 (100分)

| 問題記号 | 問題名 | 配点 | 実行時間制限/sec | メモリ制限/MB |
----|----|----|----|----
| A | Tenki | 100 | 2 | 1024 |
| B | Power Socket | 200 | 2 | 1024 |
| C | Lower | 300 | 2 | 1024 |
| D | ModSum | 400 | 2 | 1024 |
| E | League | 500 | 2 | 1024 |
| F | Engines | 600 | 2 | 1024 |

## 結果
| 順位 | パフォーマンス | 新Rating | 差分 |
----|----|----|----
| 2741/5899 | 793 | 464 | +62 |

### A - [Tenki](https://atcoder.jp/contests/abc139/tasks/abc139_a)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 03:11 | 0 | 0 | 0 | 0 |

**[Q] 3日間の天気予報を表す文字列Sと実際の天気を表す文字列Tを比較して予報が的中した日数を出力せよ.**

3分もかかったのはABCのサイトがコンテスト冒頭重かった影響(自分だけ...?). 文字列S,Tを1文字ずつ比較して, 等しければ的中数cをインクリメントする.

### B - [Power Socket](https://atcoder.jp/contests/abc139/tasks/abc139_b)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 15:26 | 0 | 0 | 1 | 0 |

**[Q] 1口の電源プラグをA個口の電源タップをいくつか使ってB口以上に拡張するためには最小でいくつの電源タップが必要か.**

1つのタップを使うとプラグがA-1口増えるので, これがB口以上になるまでプラグを増やしていく. while文を利用し, ループごとにタップ数rを1増やす.

### C - [Lower](https://atcoder.jp/contests/abc139/tasks/abc139_c)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 28:52 | 0 | 0 | 0 | 0 |

**[Q] 高さが書かれたN個のマス内がある. 右隣のマスが現在のマス以下の高さだった場合右隣に移動できる. スタートマスを好きなように選べる時, 最大で何回移動できるか.**

最長単調減少列を見つけるようにO(N)で実装した. 変数sに最初左端のマスの高さを入れ, 右隣がそれより低ければ, そのマスの高さをsに入れて, 同様に繰り返した. この繰り返しごとに単調減少列長cを増やしていった.  
右隣がそれより多ければ, 同様にsにそのマスの高さを入れた上で, cがmより大きければm=cとしてmを最長単調減少列長を表すものとして扱って更新していった. この後c=0とリセットした.  
単調減少が続く中ループが終わった場合用に, ループを抜けたあとに再度mの更新を行った. 最後にmを出力して終わり.

### D - [ModSum](https://atcoder.jp/contests/abc139/tasks/abc139_d)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 46:16 | 0 | 0 | 1 | 0 |

**[Q] 整数Nに対してN以下の自然数を並べた数列Pを選ぶ. Pの各要素P[i]をi+1で割った余りをM[i]として, sum(M)の最大値を求めよ.**

ひらめいたら一瞬の問題であった. 各要素について最大の余りを出すためには, その要素よりも大きい要素で割ればよいだけなのである. このとき(N-1-i)/(N-i)(i=0\~N-2)と割って余りを出していくとsum(M)が最大になることに気づく. なおN%1はスルー.  
この余りは1~N-1の和なので, O(N)で出力変数sに足していけばいいだけである. もっと単純に和の公式を使ってO(1)でもいけるが, O(N)でも今回の制約では問題なく, パッと思いついたのが前者だったので, 今回はO(N)で実装している.  
sはlong longでないとオーバーフローで死去. これで1回WA. オーバーフローでWAは前科ありなので猛省したい.

### E - [League](https://atcoder.jp/contests/abc139/tasks/abc139_e)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| x | 0 | (RE) | 1(+1) | 0 |

**[Q] N人による総当りのテニス大会で, 各選手の試合相手順が指定されているとき, 各選手1日最大1試合という条件ですべて満たすことは可能か. 可能な場合全試合できる最小日数を求めよ.**

本番時はvectorやsetを使ってゴリ押しで作ろうとしたがハーフACに留まりタイムオーバー. 公式解説によると試合ペアの有向グラフを作って, 閉路検出や最大パス長をDFSで求めることでO(N^2)で解けることが示されているが, 試合ペアの有向グラフを作るところがまず実装できず.  
結局コンテスト後, 数時間トライしたがACに至れず未解決問題. グラフやDFS,BFSの理解をより深めた上で後日再トライしたい.

### F - Engines
タイムオーバー

## 実績
| 順位 | Rating | Rating最高値 | コンテスト参加回数 |
----|----|----|----
| 12949 | 464(暫定) | 464-8級 | 8 |

## 感想
ABCもこれで5回目. ついに4完できたが, 今回のD問題は難易度が通常より異様に低く(完全なひらめき問題), 第一の目標を達成したものの不完全燃焼(Twitterで統計的にABC139の難易度を調査している方がいたが, 実際D問題とE問題には大きな壁があり, D問題までは頑張れば灰色でも解けるレベルだったらしい).  
B,D問題でそれぞれWAを1回出してしまい, 各問題を解くスピードもそこまで早くなかったのでパフォーマンスは低く, 4完ながら思うようにレートは上昇しなかった. D問題でまたしてもオーバーフローが原因でWAを出してしまったのは今回の1番の反省ポイントであると考えている.  
次のコンテストからの目標として4完をより早く正確に解けるようにしたい. コンテスト後E問題にチャレンジしてみたが, 現在の自分の実力とは程遠い難易度だったので, まずはD問題まで確実に解けるように今後訓練していきたい.
