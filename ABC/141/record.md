# [AtCoder Beginner Contest 141](https://atcoder.jp/contests/abc141)
2019.09.15 21:00~22:40 (100分)

| 問題記号 | 問題名 | 配点 | 実行時間制限/sec | メモリ制限/MB |
----|----|----|----|----
| A | Weather Prediction | 100 | 2 | 1024 |
| B | Tap Dance | 200 | 2 | 1024 |
| C | Attack Survival | 300 | 2 | 1024 |
| D | Powerful Discount Tickets | 400 | 2 | 1024 |
| E | Who Says a Pun? | 500 | 2 | 1024 |
| F | Xor Sum 3 | 600 | 2 | 1024 |

## 結果
| 順位 | パフォーマンス | レーティング | 差分 |
----|----|----|----
| 2110/5166 | 847 | 576 | +45 |

### A - [Weather Prediction](https://atcoder.jp/contests/abc141/tasks/abc141_a)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 02:37 | 0 | 0 | 0 | 0 |

**[Q] 晴・曇・雨と周期的に天気が変化する町の次の日の天気を予測せよ.**

Sunny->Cloudy, Cloudy->Rainy, Rainy->Sunnyとifで分けるだけ.

### B - [Tap Dance](https://atcoder.jp/contests/abc141/tasks/abc141_b)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 07:04 | 0 | 0 | 0 | 0 |

**[Q] タップダンスの動きを表す文字列において, 踏みやすい文字列(奇数文字は'R''U''D', 偶数文字は'L''U''D')かどうかを判断せよ.**

前から1文字ずつ調べていく. UとDはいつ現れても問題ないのでスルー, そうでなければ, 奇数文字なら'R', 偶数文字が'L'になっているか確認していく. B問にしてはかなり簡単な部類であったと感じる.

### C - [Attack Survival](https://atcoder.jp/contests/abc141_c/tasks/abc141_c)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 16:30 | 0 | 0 | 0 | 0 |

**[Q] 正解者以外減点方式のクイズ大会で各問題ごとに0点以下の参加者が敗退していくとき, 正解数と正解者の順番から参加者それぞれが勝ち抜けたか敗退したかを求めよ.**

あらかじめQ点全員与えておいて, 正解者のみの点数を順次増やしていく. 最後に各参加者の点数からQ点引いて0以上だったならば"Yes", そうでなければ"No"と出力させる. 正解者以外を1減らすのと正解者を1増やすのは相対的には同様の操作となるので, この方法により勝ち抜けたか敗退したか判断できる(1回も正解しなければ点数は変動せず, これにQを引くことでQ回の不正解分の点数を引くことになる).

### D - [Powerful Discount Tickets](https://atcoder.jp/contests/abc141/tasks/abc141_d)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 01:38:50 | 0 | 1 | 0 | 1 |

**[Q] i番目に買う品物の値段とM枚の割引券が与えられた時, 最小で何円あればすべての品物を買うことができるか.**

まず品物の値段をすべて読みこんでおく. この中で一番値段の高い品物に対して1枚割引券を使う. その品物の値段を更新した状態においてまた一番値段の高い品物に対して1枚割引券を使う. これをY回繰り返すことで常に割引券を使うことによる最大の割引ができるので, すべての品物を購入できる最小金額を求めることができる.  
この考え方自体は問題ない(証明は公式解説に委ねる). しかしこれを愚直に実装するとO(N^2)でTLEになってしまう. この[提出ケース](https://atcoder.jp/contests/abc141/submissions/7529432)では, 品物の価格をvectorで読み込み, max_elementを使って最大値を1/2しているがこれはTLE. max_elementの計算量はO(logN)くらいかと勝手に思い込んでいたが, 実はO(N)で, 結果的にO(N^2)になってしまっているからである. 恐らく解法は間違いないと思うのでどうにかして最大値を早く求める方法がないかと探ること1時間, APG4bのSTLコンテナのページを眺めていると「priority_queue」が最大要素取得をO(1), 最大要素削除をO(logN)でできることに気づき, これを使って実装させるとあっさり通ってしまった(O(NlogN)).  
priority_queueの存在については知っていたがすっかり忘れてしまっており, とんだ凡ミスで1時間以上も苦戦することになってしまった. なお残り1分10秒でAC.

### E - Who Says a Pun?
タイムオーバー

### F - Xor Sum 3
タイムオーバー

## 実績
| 順位 | Rating | Rating最高値 | コンテスト参加回数 |
----|----|----|----
| 11664 | 576(暫定14) | 576-8級 | 10 |

## 感想
ABC7回目. 4完だがまたも納得できない結果になった. 1時間以上も苦戦したD問題は法則さえ気づけば実はpriority_queueを使うだけでTLEせずに簡単に実装できるというもので, とても悔しい思いをすることになってしまった. priority_queueを使う問題は度々解いてきたが, なぜそれを使うことを今回思いつかなかったのかという,,,. ただ最後まで諦めずに粘ってACできたのは良かったと感じている.   
次回コンテストまでにmap,set,queue,priority_queue,stack,dequeなどSTLのコンテナの復習をしっかりしていきたいところである. それなりにD問題は解けるようになってきたので, より早く正確に解いて1000以上のパフォーマンスを稼げるようにしたい.
