# [AtCoder Beginner Contest 136](https://atcoder.jp/contests/abc136)
2019.08.04 21:00~22:40 (100分)

| 問題記号 | 問題名 | 配点 | 実行時間制限/sec | メモリ制限/MB |
----|----|----|----|----
| A | Transfer | 100 | 2 | 1024 |
| B | Uneven Numbers | 200 | 2 | 1024 |
| C | Build Stairs | 300 | 2 | 1024 |
| D | Gathering Children | 400 | 2 | 1024 |
| E | Max GCD | 500 | 2 | 1024 |
| F | Enclosed Points | 600 | 2 | 1024 |

## 結果
| 順位 | パフォーマンス | 新Rating | 差分 |
----|----|----|----
| 3363 | 507 | 269 | +33 |

### A - [Transfer](https://atcoder.jp/contests/abc136/tasks/abc136_a)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 04:04 | 0 | 0 | 0 | 0 |

**[Q] Cmlの水が入ってる容器2からBmlの水が入ってるAmlまで入れられる容器1に入れるだけ移すとき, 容器2には何mlの水が残るか.**

CがA-Bより小さければ容器2の水はすべて容器1に移せるのでCを出力する. 一方でCがA-Bより大きければ容器1にはA-B分しか移せないので, C-(A-B)=C-A+Bを出力する.

### B - [Uneven Numbers](https://atcoder.jp/contests/abc136/tasks/abc136_b)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 49:43 | 0 | 0 | 3 | 0 |

**[Q] N以下の正の整数のうち桁数が奇数であるものの個数を求めよ.**

ACできそうでできない状態が続き, B問題にしては相当苦戦した. まずACしたコードについて解説する. Nを文字列に変換し, その長さを変数lに入れた. これによりl=Nの桁数となった. 次に1以上l未満の桁数の数について, iが奇数の場合において, i桁の個数は10^(i-1)\*9個なので, これを予め用意した合計個数を扱うcに加えた. そしてlが奇数の場合はl桁の数はN-10^(l-1)+1個存在するので, これをcに加えた. l未満とl桁の場合における条件分岐などで色々混乱してなかなか答えに辿り着けなかった.  
またACしたコードでは存在しないが, 「N%pow(10,l-1)」のようなコードでエラーを吐いてしまい, 原因究明に時間を取られた. この原因としてはpowがintではなくdoubleを返すと理解してなかったことにあった(x%yのyはintでないといけない)(pow(a,b)においてaもbもdoubleで扱うので返り値がdoubleになる).  
と, 色々時間を取られてB問題ACまで50分も経過してしまうという大失態を犯してしまったが, Nの制約は最大で10^5という小さいものであり, 実はNまでの数について毎回文字列変換→sizeで長さを数える→奇数ならc++とするだけで良かった. 制約が楽にも関わらず工夫しようとしてタイムロスしてしまったわけである.

### C - [Build Stairs](https://atcoder.jp/contests/abc136/tasks/abc136_c)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| 01:04:10 | 0 | 0 | 0 | 0 |

**[Q] マスの高さが異なる横並びのN個の各マスについて, マスの高さを1低くするか何もしないかのいずれかの操作で, 左から右に向かって単調非減少にできるか調べよ.**

左から2つ目のマスからその高さについて順に調べていく. あるマスについて左のマスよりも大きい場合は単調非減少になっている. この場合調べているマスの高さを1低くしておく. 一方で左のマスよりも小さい場合は探査for文から抜ける. 左のマスよりも大きい場合に高さを1低くして等しいときは何も減らしてないとすることで, そのマスはそれ以上低くする操作ができなくなっており, 左のマスの方が大きいとなった時点で対象操作で単調非減少にすることが不可能となる.  
よってforブロックを過ぎた後, i=Nなら最後までfor文を繰り返したことになるので単調非減少にできたとわかるので「Yes」, i≠Nなら途中で抜けているのであるマスにおいて単調非減少が成立しなくなったとわかるので「No」を出力している.  
C問題にしてはすんなり解けた印象であった.

### D - [Gathering Children](https://atcoder.jp/contests/abc136/tasks/abc136_d)
| AC | CE | RE | WA | TLE |
----|----|----|----|----
| (01:50:59) | 0 | 0 | 1(+1) | 0 |

**[Q] LとRが書かれたマスの上に子供が1人ずつおり, Lなら左隣, Rなら右隣に移動するという規則に従った移動を10^100回繰り返したとき, 各マスに居る子供の人数を求めよ.**

マスの長さの制約と移動回数を比較すると, 移動回数はマスの長さに対して十分に多いといえる. つまり"RL"と並んだところに子供が集中すると予想できる. 変数lにマスの長さを入れ, 左端のマスから順に各マスの文字を調べていき, その条件で変数x,y,zを操作し, 出力マス配列r(初期値0)の値を変更していった.  
「R...RL...L」(左端Rの左隣はL, 右端Lの右隣はR)となるブロックを見つけていき, ブロックを見つけ終わったとき, xにはブロックの長さ, yに「RL」となる「R」の位置, zにはブロック内のRの長さが入っているようにした. 「LR」となったとき(ブロックの終点), x(ブロック長)が偶数のとき, 「RL」となる各マスにはブロック長/2の子供が集まる. xが奇数のときはブロック長を余りが出るように等分した上で, y(ブロック内R長)が偶数ならLの方に1人多く集まり, 奇数ならRの方に1人多く集まることになる. このようにして配列rの値を変更していった.  
最終的にブロックが完結するとは限らないので, for文を終えたあとに一度x,y,zの値をチェックして, 配列rの値を変更する処理を行った. これにより実装できた.  
模範解答ではランレングス圧縮ライブラリを用意したり, dpを使った解法が紹介されてたが, dpは使わずに一応ACはできた. ただdpを使った解法の方はLR移動が複雑化した場合(xマス移動)でも対応できるため拡張性が高いようである.  
ACは1時間50分で制限時間を10分オーバーしてしまい, 惜しくも初の4完には至らなかった. Bに時間を取られたことが一番の原因だが, D問題において当初, 制約の条件2(左端は必ずRで右端は必ずL)を見逃してしばらくコード作成を進めていたのでタイムロスしてしまい, このミスが無ければ4完できていたと思う.　　

### E - Max GCD
タイムオーバー

### F - Enclosed Points
タイムオーバー

## 実績
| 順位 | Rating | Rating最高値 | コンテスト参加回数 |
----|----|----|----
| 15876 | 269(暫定) | 269-9級 | 6 |

## 感想
ABC4回目. 今までで一番4完の可能性があったが, またもや3完という結果になった. D問題にも原因があると思うが(先述), 一番の原因はB問題に相当時間を食われたことにあると思う. B問題は工夫して解こうとして苦戦した結果タイムロスしてしまったが, 実は制約条件的に工夫を全くしなくても良いという問題であり, 非常に勿体ないことをしてしまった.  
競プロの勉強を進めていき段々と色んな知識が身についてきた中で起こってしまったことであり, 一度冷静になり初心に返って単純な解き方を模索することも必要であると今回のコンテストでよくわかった. D問題はABC135のDPリベンジとはならなかったが, 別の解法でも一番スムーズにACできたので満足している. 次こそ4完目指して, 夏休みにも入ったので競プロの勉強をより究めていきたい.
